#!/bin/sh

## Defaults
### Options
MOMMY_OPT_CONFIG_FILE="$HOME/.config/mommy/config.sh"
MOMMY_OPT_HELP=""
MOMMY_OPT_EVAL=""

### Configuration
MOMMY_PET_NAME="girl"
MOMMY_PRONOUN="her"
MOMMY_ROLE="mommy"
MOMMY_SUFFIX="~ ❤️"

MOMMY_CAPITALIZE="0"

MOMMY_COMPLIMENTS="
good %%PET_NAME%%
/that's a good %%PET_NAME%%
/%%ROLE%% is so proud of you
/%%ROLE%% thinks you deserve a special treat for that
/don't forget to take a break when you feel tired, little %%PET_NAME%%
/%%ROLE%% loves you, you are doing amazing
/%%ROLE%% knew you could do it
"
MOMMY_COMPLIMENTS_EXTRA=""
MOMMY_COMPLIMENTS_ENABLED="1"

MOMMY_ENCOURAGEMENTS="
/%%ROLE%% knows %%PRONOUN%% little %%PET_NAME%% can do better
/%%ROLE%% is always here for you if you need %%PRONOUN%%
/aww, did %%ROLE%%'s %%PET_NAME%% make a big mess? %%ROLE%% can help you clean up
/just a little further, %%ROLE%% knows you can do it
/%%ROLE%% believes in you
/aww, come here, sit on my lap while you regain your courage
/%%ROLE%% promises whatever happens %%ROLE%% will be here for you
/%%ROLE%% believes in you because you're my good %%PET_NAME%%
"
MOMMY_ENCOURAGEMENTS_EXTRA=""
MOMMY_ENCOURAGEMENTS_ENABLED="1"

MOMMY_FORBIDDEN_WORDS=""


## Lists
# A list is a collection of entries. An entry is a string, possibly multiline. An entry does not start or end with a
# whitespace character. A list is represented by a string, consisting of the entries separated by `/`s. A list does not
# have leading or trailing `/`s.

# Joins all lists from the input arguments into a single list.
lists_join() {
    printf "%s/" "$@" | head -c -1
}

# Removes all whitespace-only entries from the list in stdin. As a result, consecutive `/`s and leading and trailing
# `/`s are removed.
list_sanitize() {
    list="$(cat)/"

    sanitized_list=""
    while [ -n "$list" ]; do
        entry="${list%%/*}"

        if [ -n "$(printf "%s" "$entry" | tr -d "[:space:]")" ]; then
            sanitized_list="$sanitized_list$entry/"
        fi

        list="${list#*/}"
    done

    printf "%s" "$sanitized_list" | head -c -1
    return 0
}

# Outputs 0 if the string `$1` contains any of the substrings in the list `$2`, and outputs 1 otherwise.
list_contains_any() {
    list="$2/"

    while [ -n "$list" ]; do
        if [ -z "${1##*"${list%%/*}"*}" ]; then
            printf "0"
            return 0
        fi

        list="${list#*/}"
    done

    printf "1"
    return 0
}

# Removes all entries from the list in stdin that contain any of the entries in `$1` as a substring.
list_exclude_if_contains() {
    if [ -z "$1" ]; then
        cat
        return 0
    fi

    list="$(cat)/"
    filtered_list=""
    while [ -n "$list" ]; do
        entry="${list%%/*}"

        if [ "$(list_contains_any "$entry" "$1")" -ne 0 ]; then
            filtered_list="$filtered_list$entry/"
        fi

        list="${list#*/}"
    done

    printf "%s" "$filtered_list" | head -c -1
    return 0
}

# Writes a random entry from the list in stdin to stdout.
list_choose_random() {
    list="$(cat)/"
    count="$(printf "%s" "$list" | grep -o "/" | wc -l)"
    idx="$(shuf -i 1-"$count" -n 1)"

    i="1"
    while [ -n "$list" ]; do
        if [ "$i" -eq "$idx" ]; then
            printf "%s" "${list%%/*}"
            return 0
        fi

        list="${list#*/}"
        i="$((i+1))"
    done
}


## Functions
# Reads stdin; if `$1` is `0`, the first character on each line is changed to lowercase, if `$1` is `1`, the first
# character on each line is changed to uppercase, and otherwise nothing is changed; and writes to stdout.
capitalize_lines() {
    entry="$(cat)"
    if [ "$1" = "0" ]; then
        mapping="tolower"
    elif [ "$1" = "1" ]; then
        mapping="toupper"
    else
        printf "%s" "$entry"
        return 0
    fi

    printf "%s" "$entry" | awk "{ print $mapping(substr(\$0, 1, 1)) substr(\$0, 2) }"
    return 0
}

# Reads stdin, and
# 1. replaces
#    * `%%PET_NAME%%` with `$1`,
#    * `%%PRONOUN%%` with `$2`, and
#    * `%%ROLE%%` with `$3`;
# 2. applies `capitalize_lines` using `$5` as the choice parameter;
# 3. removes leading and trailing newlines;
# 4. appends `$4`; and
# 5. writes to stdout.
fill_template() {
    output=$(cat |
                 sed -e "s/%%PET_NAME%%/$1/g" -e "s/%%PRONOUN%%/$2/g" -e "s/%%ROLE%%/$3/g" |
                 capitalize_lines "$5" |
                 sed -e "1h;2,\$H;\$!d;g" -e "s/^\n*//" -e "s/\n*$//")
    printf "%s" "$output" "$4"
    return 0
}

# Reads stdin and invokes `fill_template` using the expected global parameters.
fill_template_with_globals() {
    cat | fill_template "$pet_name" "$pronoun" "$role" "$suffix" "$MOMMY_CAPITALIZE"
    return 0
}


## Read options
if [ "$1" = "--help" ]; then
    MOMMY_OPT_HELP="1"
fi

while getopts ":hc:e:s:" OPTION; do
    case "$OPTION" in
    h) MOMMY_OPT_HELP="1" ;;
    c) MOMMY_OPT_CONFIG_FILE="$OPTARG" ;;
    e) MOMMY_OPT_EVAL="$OPTARG" ;;
    s) MOMMY_OPT_STATUS="$OPTARG" ;;
    ?) ;;
    esac
done

shift "$((OPTIND - 1))"


## Load configuration
# shellcheck source=/dev/null
test -f "$MOMMY_OPT_CONFIG_FILE" && . "$MOMMY_OPT_CONFIG_FILE"

# Read lists
forbidden_words=$(printf "%s" "$MOMMY_FORBIDDEN_WORDS" | list_sanitize)

compliments=$(lists_join "$MOMMY_COMPLIMENTS" "$MOMMY_COMPLIMENTS_EXTRA" |
                  list_sanitize |
                  list_exclude_if_contains "$forbidden_words")
encouragements=$(lists_join "$MOMMY_ENCOURAGEMENTS" "$MOMMY_ENCOURAGEMENTS_EXTRA" |
                     list_sanitize |
                     list_exclude_if_contains "$forbidden_words")

pet_names=$(printf "%s" "$MOMMY_PET_NAME" | list_sanitize)
pronouns=$(printf "%s" "$MOMMY_PRONOUN" | list_sanitize)
roles=$(printf "%s" "$MOMMY_ROLE" | list_sanitize)
suffixes=$(printf "%s" "$MOMMY_SUFFIX" | list_sanitize)

# Randomize
pet_name=$(printf "%s" "$pet_names" | list_choose_random)
pronoun=$(printf "%s" "$pronouns" | list_choose_random)
role=$(printf "%s" "$roles" | list_choose_random)
suffix=$(printf "%s" "$suffixes" | list_choose_random)

compliment=$(printf "%s" "$compliments" | list_choose_random | fill_template_with_globals)
encouragement=$(printf "%s" "$encouragements" | list_choose_random | fill_template_with_globals)


## Output
if [ -n "$MOMMY_OPT_HELP" ]; then
    global_man_path="/usr/share/man/man1/mommy.1.gz"
    local_man_path="$(dirname -- "$0")/../resources/mommy.1"

    if [ -f "$local_man_path" ]; then
        man -l "$local_man_path" | cat
        return 0
    elif [ -f "$global_man_path" ]; then
        man mommy | cat
        return 0
    else
        echo "could not find the manual page~" | fill_template_with_globals >&2
        return 1
    fi
else
    if [ -n "$MOMMY_OPT_EVAL" ]; then
        (eval "$MOMMY_OPT_EVAL")
        command_exit_code=$?
    elif [ -n "$MOMMY_OPT_STATUS" ]; then
        command_exit_code=$MOMMY_OPT_STATUS
    else
        ("$@")
        command_exit_code=$?
    fi

    if [ $command_exit_code -eq 0 ]; then
        if [ "$MOMMY_COMPLIMENTS_ENABLED" = "1" ]; then
            echo "$compliment"
        fi
        return 0
    else
        if [ "$MOMMY_ENCOURAGEMENTS_ENABLED" = "1" ]; then
            echo "$encouragement" >&2
        fi
        return $command_exit_code
    fi
fi
