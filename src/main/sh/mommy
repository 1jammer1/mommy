#!/bin/sh

## Defaults
### Options
MOMMY_OPT_CONFIG_FILE="$HOME/.config/mommy/config.sh"

### Configuration
MOMMY_CAREGIVER="mommy"
MOMMY_THEIR="her"
MOMMY_SWEETIE="girl"
MOMMY_SUFFIX="~"
MOMMY_COLOR="005"

MOMMY_CAPITALIZE="0"

MOMMY_COMPLIMENTS="
# generic~
/*pets your head*
/amazing work as always

# good X~
/good %%SWEETIE%%
/good job, %%SWEETIE%%
/that's a good %%SWEETIE%%
/who's my good %%SWEETIE%%

# proud~
/%%CAREGIVER%% is very proud of you
/%%CAREGIVER%% is so proud of you
/%%CAREGIVER%% knew you could do it
/%%CAREGIVER%% loves you, you are doing amazing

# compliment~
/%%CAREGIVER%%'s %%SWEETIE%% is so smart

# reward~
/%%CAREGIVER%% thinks you deserve a special treat for that
/my little %%SWEETIE%% deserves a big fat kiss for that
"
MOMMY_COMPLIMENTS_EXTRA=""
MOMMY_COMPLIMENTS_ENABLED="1"

MOMMY_ENCOURAGEMENTS="
# trust~
/%%CAREGIVER%% believes in you
/%%CAREGIVER%% knows you'll get there
/%%CAREGIVER%% knows %%THEIR%% little %%SWEETIE%% can do better
/just know that %%CAREGIVER%% still loves you

# consolation~
/%%CAREGIVER%% knows it's hard, but it will be okay

# fallback~
/%%CAREGIVER%% is always here for you
/%%CAREGIVER%% is always here for you if you need %%THEIR%%
/come here, sit on my lap while we figure this out together
/%%CAREGIVER%% promises that, whatever happens, %%CAREGIVER%% will be here for you

# encouragement~
/never give up, my love
/just a little further, %%CAREGIVER%% knows you can do it
/%%CAREGIVER%% knows you'll get there, don't worry about it

# clean up~
/did %%CAREGIVER%%'s %%SWEETIE%% make a big mess?
"
MOMMY_ENCOURAGEMENTS_EXTRA=""
MOMMY_ENCOURAGEMENTS_ENABLED="1"

MOMMY_FORBIDDEN_WORDS=""


## Lists
# A list is a collection of entries. An entry is a string, possibly multiline. An entry does not start or end with a
# whitespace character. A list is represented by a string, consisting of the entries separated by `/`s. A list does not
# have leading or trailing `/`s.

# Outputs `0` if the string `$1` contains any of the substrings in the list `$2`, and outputs `1` otherwise.
list_contains_any() {
    if [ "$2" = "" ]; then
        printf "1"
        return 0
    fi

    list="$2/"
    while [ -n "$list" ]; do
        if [ -z "${1##*"${list%%/*}"*}" ]; then
            printf "0"
            return 0
        fi

        list="${list#*/}"
    done

    printf "1"
    return 0
}

# Takes the list in stdin and removes (1) all whitespace-only entries, (2) all entries containing one of the words in
# the list in `$1`, and (3) all lines starting with `#`. As a result of (1), consecutive `/`s and leading and trailing
# `/`s are removed.
list_sanitize() {
    list="$(cat | grep -v "^#")/"

    sanitized_list=""
    while [ -n "$list" ]; do
        entry="${list%%/*}"

        if [ -n "$(printf "%s" "$entry" | tr -d "[:space:]")" ] && [ "$(list_contains_any "$entry" "$1")" -ne 0 ]; then
            sanitized_list="$sanitized_list$entry/"
        fi

        list="${list#*/}"
    done

    printf "%s" "${sanitized_list%?}"
    return 0
}

# Writes a random entry from the list in stdin to stdout.
list_choose() {
    list="$(cat)/"
    count="$(printf "%s" "$list" | tr -cd "/" | wc -c)"
    if [ -x "$(command -v shuf)" ]; then
        idx="$(shuf -i 1-"$count" -n 1)"
    else
        idx="$(jot -r 1 1 "$count")"
    fi

    i="1"
    while [ -n "$list" ]; do
        if [ "$i" -eq "$idx" ]; then
            printf "%s" "${list%%/*}"
            return 0
        fi

        list="${list#*/}"
        i="$((i+1))"
    done
}


## Functions
# Prints stdin, but with color depending on `$1`. If `$1` equals `lolcat`, stdin is piped to `lolcat`. If `$1` is empty,
# or color is not enabled in the terminal, stdin is printed normally. Otherwise, `$1` is used as the xterm color.
color_cat() {
    input="$(cat)"
    if [ "$1" = "lolcat" ]; then
        echo "$input" | lolcat -f
    elif [ -z "$1" ] || [ ! -t 1 ] && [ ! -t 2 ] || [ -z "$(tput colors)" ] || [ "$(tput colors)" -lt 8 ]; then
        echo "$input"
    else
        echo "$(tput setaf "$1")$input$(tput sgr0)"
    fi
    return 0
}

# Reads stdin; if `$1` is `0`, the first character on each line is changed to lowercase, if `$1` is `1`, the first
# character on each line is changed to uppercase, and otherwise nothing is changed; and writes to stdout.
capitalize_lines() {
    if [ "$1" = "0" ]; then
        mapping="tolower"
    elif [ "$1" = "1" ]; then
        mapping="toupper"
    else
        cat
        return 0
    fi

    cat | awk "{ print $mapping(substr(\$0, 1, 1)) substr(\$0, 2) }"
    return 0
}

# Reads stdin, and
# 1. replaces
#    * `%%SWEETIE%%` with a random entry from `$1`,
#    * `%%THEIR%%` with a random entry from `$2`, and
#    * `%%CAREGIVER%%` with a random entry from `$3`;
# 2. applies `capitalize_lines` using `$5` as the choice parameter;
# 3. removes leading and trailing newlines;
# 4. appends `$4`; and
# 5. writes to stdout.
fill_template() {
    sweetie=$(printf "%s" "$1" | list_sanitize | list_choose)
    their=$(printf "%s" "$2" | list_sanitize | list_choose)
    caregiver=$(printf "%s" "$3" | list_sanitize | list_choose)
    suffix=$(printf "%s" "$4" | list_sanitize | list_choose)

    output="$(printf "%s\n" "$(cat)" |
                  sed -e "s/%%SWEETIE%%/$sweetie/g" -e "s/%%THEIR%%/$their/g" -e "s/%%CAREGIVER%%/$caregiver/g" |
                  capitalize_lines "$5" |
                  sed -e "1h;2,\$H;\$!d;g" -e "s/^\n*//" -e "s/\n*$//")"
    printf "%s" "$output" "$suffix"
    return 0
}


## Read options
if [ "$1" = "--help" ]; then
    MOMMY_OPT_HELP="1"
fi

while getopts ":hc:e:s:" OPTION; do
    case "$OPTION" in
    h) MOMMY_OPT_HELP="1" ;;
    c) MOMMY_OPT_CONFIG_FILE="$OPTARG" ;;
    e) MOMMY_OPT_EVAL="$OPTARG" ;;
    s) MOMMY_OPT_STATUS="$OPTARG" ;;
    ?) ;;
    esac
done

shift "$((OPTIND - 1))"


## Load configuration
# shellcheck source=/dev/null
test -f "$MOMMY_OPT_CONFIG_FILE" && . "$MOMMY_OPT_CONFIG_FILE"


## Output
if [ -n "$MOMMY_OPT_HELP" ]; then
    local_man_path="$(dirname -- "$0")/../resources/mommy.1"

    if [ -f "$local_man_path" ]; then
        man "$local_man_path"
        exit "$?"
    else
        man mommy
        exit "$?"
    fi
else
    if [ -n "$MOMMY_OPT_EVAL" ]; then
        (eval "$MOMMY_OPT_EVAL")
        command_exit_code="$?"
    elif [ -n "$MOMMY_OPT_STATUS" ]; then
        command_exit_code="$MOMMY_OPT_STATUS"
    else
        ("$@")
        command_exit_code="$?"
    fi

    if [ "$command_exit_code" -eq 0 ] && [ "$MOMMY_COMPLIMENTS_ENABLED" = "1" ]; then
        templates="$MOMMY_COMPLIMENTS/$MOMMY_COMPLIMENTS_EXTRA"
    elif [ "$command_exit_code" -ne 0 ] && [ "$MOMMY_ENCOURAGEMENTS_ENABLED" = "1" ]; then
        templates="$MOMMY_ENCOURAGEMENTS/$MOMMY_ENCOURAGEMENTS_EXTRA"
    else
        exit "$command_exit_code"
    fi

    color=$(printf "%s" "$MOMMY_COLOR" | list_sanitize | list_choose)
    forbidden_words=$(printf "%s" "$MOMMY_FORBIDDEN_WORDS" | list_sanitize)

    printf "%s" "$templates" |
        list_sanitize "$forbidden_words" |
        list_choose |
        fill_template "$MOMMY_SWEETIE" "$MOMMY_THEIR" "$MOMMY_CAREGIVER" "$MOMMY_SUFFIX" "$MOMMY_CAPITALIZE" |
        color_cat "$color" >&2
    exit "$command_exit_code"
fi
